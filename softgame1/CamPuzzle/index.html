<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Sliding Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #2d5a3d 0%, #1a3d2e 100%);
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2rem;
            max-width: 800px;
            width: 100%;
        }

        .neumorphic {
            background: #2d5a3d;
            border-radius: 20px;
            box-shadow: 
                20px 20px 60px #1a3d2e,
                -20px -20px 60px #407a4f;
        }

        .neumorphic-button {
            background: #2d5a3d;
            border: none;
            border-radius: 15px;
            color: #e2e8f0;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 
                8px 8px 16px #1a3d2e,
                -8px -8px 16px #407a4f;
        }

        .neumorphic-button:hover {
            box-shadow: 
                4px 4px 8px #1a3d2e,
                -4px -4px 8px #407a4f;
            transform: translateY(1px);
        }

        .neumorphic-button:active {
            box-shadow: 
                inset 4px 4px 8px #1a3d2e,
                inset -4px -4px 8px #407a4f;
            transform: translateY(2px);
        }

        .game-board {
            position: relative;
            display: grid;
            gap: 0.5rem;
            border-radius: 20px;
            overflow: hidden;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            background: #2d5a3d;
            box-shadow: 
                20px 20px 60px #1a3d2e,
                -20px -20px 60px #407a4f;
            padding: 1rem;
        }

        .tile {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 12px;
            box-shadow: 
                6px 6px 12px #1a3d2e,
                -6px -6px 12px #407a4f;
        }

        .tile:hover:not(.empty) {
            transform: translateY(-2px);
            box-shadow: 
                8px 8px 16px #1a3d2e,
                -8px -8px 16px #407a4f;
        }

        .tile.empty {
            background: #2d5a3d;
            background-image: none !important;
            box-shadow: 
                inset 4px 4px 8px #1a3d2e,
                inset -4px -4px 8px #407a4f;
            cursor: default;
        }

        .camera-preview, .captured-image-preview {
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            border-radius: 15px;
            object-fit: cover;
            box-shadow: 
                8px 8px 16px #1a3d2e,
                -8px -8px 16px #407a4f;
            background: #2d5a3d;
        }

        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 61, 46, 0.95);
            backdrop-filter: blur(10px);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 1.5rem;
            text-align: center;
            border-radius: 20px;
            z-index: 10;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
        }

        .modal.visible {
            opacity: 1;
            visibility: visible;
        }

        .start-button {
            padding: 1rem 2.5rem;
            font-size: 1.1rem;
            border-radius: 15px;
        }

        .snapshot-button {
            padding: 0.75rem 1.5rem;
            font-size: 0.9rem;
            border-radius: 12px;
            margin: 0.5rem;
        }

        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .title {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            text-align: center;
            color: #a7c7a7;
            margin-bottom: 2rem;
            max-width: 500px;
            line-height: 1.6;
        }

        .camera-container, .captured-image-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .captured-image-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #e2e8f0;
            margin: 0;
        }

        .game-stats {
            display: flex;
            gap: 2rem;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: #2d5a3d;
            border-radius: 15px;
            box-shadow: 
                8px 8px 16px #1a3d2e,
                -8px -8px 16px #407a4f;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #a7c7a7;
            font-weight: 600;
        }

        .stat-value {
            font-size: 1.5rem;
            color: #e2e8f0;
            font-weight: 700;
        }

        @media (max-width: 640px) {
            .title { font-size: 2rem; }
            .game-board { max-width: 400px; gap: 0.3rem; }
            .controls { flex-direction: column; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div>
            <h1 class="title">Webcam Puzzle</h1>
            <p class="subtitle">Use your webcam to create a unique sliding puzzle. Click a tile next to the empty space to solve the puzzle!</p>
        </div>

        <div class="game-board neumorphic">
            <div id="game-container" class="grid w-full h-full"></div>
            <div id="welcome-modal" class="modal visible">
                <h2 id="modal-title" class="text-3xl font-bold mb-4">Welcome to Webcam Puzzle!</h2>
                <p class="text-lg mb-6 text-gray-300">Allow camera access to start playing.</p>
                <button id="startButton" class="start-button neumorphic-button">Start Game</button>
            </div>
        </div>

        <div id="camera-container" class="camera-container" style="display: none;">
            <video id="camera-preview" class="camera-preview" autoplay muted playsinline></video>
            <div class="controls">
                <button id="snapshotButton" class="snapshot-button neumorphic-button">Take New Snapshot</button>
                <button id="newGameButton" class="snapshot-button neumorphic-button">New Game (Same Image)</button>
            </div>
        </div>

        <div id="captured-image-container" class="captured-image-container" style="display: none;">
            <h3 class="captured-image-title">Puzzle Image</h3>
            <canvas id="captured-image-preview" class="captured-image-preview"></canvas>
        </div>

        <div id="game-stats" class="game-stats" style="display: none;">
            <div class="stat-item">
                <span class="stat-label">Time:</span>
                <span id="time-display" class="stat-value">00:00</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Moves:</span>
                <span id="moves-display" class="stat-value">0</span>
            </div>
        </div>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const startButton = document.getElementById('startButton');
        const welcomeModal = document.getElementById('welcome-modal');
        const modalTitle = document.getElementById('modal-title');
        const video = document.getElementById('camera-preview');
        const cameraContainer = document.getElementById('camera-container');
        const snapshotButton = document.getElementById('snapshotButton');
        const newGameButton = document.getElementById('newGameButton');
        const gameStats = document.getElementById('game-stats');
        const timeDisplay = document.getElementById('time-display');
        const movesDisplay = document.getElementById('moves-display');
        const capturedImageContainer = document.getElementById('captured-image-container');
        const capturedImagePreview = document.getElementById('captured-image-preview');
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const previewCtx = capturedImagePreview.getContext('2d');
        const gridSize = 3;
        
        let tiles = [];
        let emptyTileIndex;
        let isSolving = false;
        let gameStarted = false;
        let snapshotImageData = null;
        let gameStartTime = null;
        let moveCount = 0;
        let gameTimer = null;

        function startTimer() {
            stopTimer();
            gameStartTime = Date.now();
            gameTimer = setInterval(updateTimer, 1000);
            updateTimer();
        }

        function stopTimer() {
            clearInterval(gameTimer);
            gameTimer = null;
        }

        function updateTimer() {
            if (!gameStartTime) return;
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            timeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function updateMoves() {
            movesDisplay.textContent = moveCount;
        }

        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 640 },
                        aspectRatio: 1.0,
                        facingMode: 'user'
                    } 
                });
                video.srcObject = stream;
                return true;
            } catch (err) {
                console.error("Error accessing the camera:", err);
                modalTitle.textContent = "Camera Access Denied";
                document.querySelector('.modal p').textContent = "Please allow camera access in your browser settings to play.";
                startButton.style.display = 'none';
                welcomeModal.classList.add('visible');
                return false;
            }
        }
        
        function captureAndSetImage() {
            if (video.readyState < 2) return;

            const size = Math.min(video.videoWidth, video.videoHeight);
            if (size === 0) return; 
            
            canvas.width = size;
            canvas.height = size;
            const offsetX = (video.videoWidth - size) / 2;
            const offsetY = (video.videoHeight - size) / 2;
            
            ctx.drawImage(video, offsetX, offsetY, size, size, 0, 0, size, size);
            snapshotImageData = ctx.getImageData(0, 0, size, size);
            
            video.style.display = 'none';
            capturedImageContainer.style.display = 'flex';
            previewCtx.canvas.width = 500;
            previewCtx.canvas.height = 500;
            previewCtx.drawImage(canvas, 0, 0, 500, 500);
            
            updateTileImages();
        }
        
        function renderBoard() {
            gameContainer.innerHTML = '';
            gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

            tiles.forEach((tile, index) => {
                const tileDiv = document.createElement('div');
                tileDiv.classList.add('tile');
                
                if (tile.originalIndex === -1) {
                    tileDiv.classList.add('empty');
                } else {
                    tileDiv.addEventListener('click', () => handleTileClick(index));
                }
                
                gameContainer.appendChild(tileDiv);
            });

            if (snapshotImageData) {
                updateTileImages();
            }
        }

        function updateTileImages() {
            if (!snapshotImageData) return;

            const tileWidth = canvas.width / gridSize;
            const tileHeight = canvas.height / gridSize;
            const tileDivs = Array.from(gameContainer.children);

            tiles.forEach((tile, index) => {
                const tileDiv = tileDivs[index];
                if (tile.originalIndex !== -1) {
                    const row = Math.floor(tile.originalIndex / gridSize);
                    const col = tile.originalIndex % gridSize;
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = tileWidth;
                    tempCanvas.height = tileHeight;
                    const imgData = ctx.getImageData(col * tileWidth, row * tileHeight, tileWidth, tileHeight);
                    tempCanvas.getContext('2d').putImageData(imgData, 0, 0);
                    tileDiv.style.backgroundImage = `url(${tempCanvas.toDataURL()})`;
                }
            });
        }
        
        function initializePuzzle() {
            tiles = Array.from({ length: gridSize * gridSize }, (_, i) => ({ originalIndex: i }));
            emptyTileIndex = gridSize * gridSize - 1;
            tiles[emptyTileIndex].originalIndex = -1;

            do {
                shuffleTiles();
            } while (!isSolvable() || isSolved());
        }

        function shuffleTiles() {
            for (let i = tiles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
            }
            emptyTileIndex = tiles.findIndex(tile => tile.originalIndex === -1);
        }

        function isSolvable() {
            let inversions = 0;
            const flatPuzzle = tiles.map(t => t.originalIndex).filter(i => i !== -1);
            for (let i = 0; i < flatPuzzle.length - 1; i++) {
                for (let j = i + 1; j < flatPuzzle.length; j++) {
                    if (flatPuzzle[i] > flatPuzzle[j]) {
                        inversions++;
                    }
                }
            }
            return inversions % 2 === 0;
        }

        function isSolved() {
            for (let i = 0; i < tiles.length - 1; i++) {
                if (tiles[i].originalIndex !== i) return false;
            }
            return tiles[tiles.length - 1].originalIndex === -1;
        }

        function handleTileClick(clickedPosition) {
            if (isSolving) return;

            const isAdjacent = 
                (Math.abs(clickedPosition - emptyTileIndex) === 1 && Math.floor(clickedPosition / gridSize) === Math.floor(emptyTileIndex / gridSize)) ||
                (Math.abs(clickedPosition - emptyTileIndex) === gridSize);

            if (isAdjacent) {
                [tiles[clickedPosition], tiles[emptyTileIndex]] = [tiles[emptyTileIndex], tiles[clickedPosition]];
                emptyTileIndex = clickedPosition;
                moveCount++;
                updateMoves();
                renderBoard();

                if (isSolved()) {
                    isSolving = true;
                    stopTimer();
                    setTimeout(() => showWinModal(), 300);
                }
            }
        }
        
        function showWinModal() {
            tiles[emptyTileIndex].originalIndex = emptyTileIndex;
            renderBoard();

            welcomeModal.classList.add('visible');
            modalTitle.textContent = "ðŸŽ‰ Congratulations! ðŸŽ‰";
            document.querySelector('.modal p').textContent = `You solved it in ${moveCount} moves!`;
            startButton.textContent = "Play Again";
        }

        function initializeAndCapture() {
            initializePuzzle();
            renderBoard();
            captureAndSetImage();
            startTimer();
        }
        
        async function startGame() {
            welcomeModal.classList.remove('visible');
            gameStarted = true;
            isSolving = false;
            moveCount = 0;
            
            gameStats.style.display = 'flex';
            updateMoves();
            
            cameraContainer.style.display = 'flex';
            video.style.display = 'block';
            snapshotButton.style.display = 'block';
            newGameButton.style.display = 'block';
            
            if (video.readyState >= 2) {
                initializeAndCapture();
            } else {
                video.addEventListener('loadeddata', initializeAndCapture, { once: true });
            }
        }

        // Reshuffles the puzzle with the same image
        function newGame() {
            isSolving = false;
            moveCount = 0;
            updateMoves();
            welcomeModal.classList.remove('visible');
            
            initializePuzzle();
            renderBoard();
            
            startTimer();
        }
        
        // Shows the camera to take a new picture, then starts a new game
        function handleNewSnapshotClick() {
            isSolving = false;
            moveCount = 0;
            updateMoves();
            welcomeModal.classList.remove('visible');

            video.style.display = 'block';
            capturedImageContainer.style.display = 'none';

            setTimeout(() => {
                initializeAndCapture();
            }, 200);
        }

        startButton.addEventListener('click', async () => {
            if (gameStarted) { // "Play Again" was clicked
                handleNewSnapshotClick();
            } else { // First time starting
                const cameraSuccess = await setupCamera();
                if (cameraSuccess) startGame();
            }
        });

        snapshotButton.addEventListener('click', handleNewSnapshotClick);
        newGameButton.addEventListener('click', newGame);

    </script>
</body>
</html>

